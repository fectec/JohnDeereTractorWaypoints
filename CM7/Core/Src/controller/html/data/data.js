var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"robocar_c","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/Users/saucesaft/Documents/MATLAB/5to_Semestre/setpoint/robocar_c_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'robocar_c'.\n *\n * Model version                  : 2.43\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Fri Nov 29 12:10:28 2024\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"robocar_c.h\"                 /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    rtmSetErrorStatus(rtM, \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  robocar_c_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  robocar_c_initialize();\n\n  /* Attach rt_OneStep to a timer or interrupt service routine with\n   * period 0.05 seconds (base rate of the model) here.\n   * The call syntax for rt_OneStep is\n   *\n   *  rt_OneStep();\n   */\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\n    /*  Perform application tasks here */\n  }\n\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"robocar_c.c","type":"source","group":"model","path":"/Users/saucesaft/Documents/MATLAB/5to_Semestre/setpoint/robocar_c_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: robocar_c.c\n *\n * Code generated for Simulink model 'robocar_c'.\n *\n * Model version                  : 2.43\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Fri Nov 29 12:10:28 2024\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#include \"robocar_c.h\"\n#include \"rtwtypes.h\"\n#include <math.h>\n#include \"math.h\"\n\n/* Block signals and states (default storage) */\nDW rtDW;\n\n/* External inputs (root inport signals with default storage) */\nExtU rtU;\n\n/* External outputs (root outports fed by signals with default storage) */\nExtY rtY;\n\n/* Real-time model */\nstatic RT_MODEL rtM_;\nRT_MODEL *const rtM = &rtM_;\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\n\n/* Forward declaration for local functions */\nstatic real_T norm(const real_T x[2]);\nstatic real_T closestPointOnLine(const real_T pt1[2], real_T pt2[2], const\n  real_T refPt[2]);\nstatic real_T rtGetNaN(void);\nstatic real32_T rtGetNaNF(void);\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nstatic boolean_T rtIsInf(real_T value);\nstatic boolean_T rtIsInfF(real32_T value);\nstatic boolean_T rtIsNaN(real_T value);\nstatic boolean_T rtIsNaNF(real32_T value);\nreal_T rtNaN = -(real_T)NAN;\nreal_T rtInf = (real_T)INFINITY;\nreal_T rtMinusInf = -(real_T)INFINITY;\nreal32_T rtNaNF = -(real32_T)NAN;\nreal32_T rtInfF = (real32_T)INFINITY;\nreal32_T rtMinusInfF = -(real32_T)INFINITY;\n\n/* Return rtNaN needed by the generated code. */\nstatic real_T rtGetNaN(void)\n{\n  return rtNaN;\n}\n\n/* Return rtNaNF needed by the generated code. */\nstatic real32_T rtGetNaNF(void)\n{\n  return rtNaNF;\n}\n\n/* Test if value is infinite */\nstatic boolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)isinf(value);\n}\n\n/* Test if single-precision value is infinite */\nstatic boolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)isinf(value);\n}\n\n/* Test if value is not a number */\nstatic boolean_T rtIsNaN(real_T value)\n{\n  return (boolean_T)(isnan(value) != 0);\n}\n\n/* Test if single-precision value is not a number */\nstatic boolean_T rtIsNaNF(real32_T value)\n{\n  return (boolean_T)(isnan(value) != 0);\n}\n\nstatic real_T norm(const real_T x[2])\n{\n  real_T absxk;\n  real_T scale;\n  real_T t;\n  real_T y;\n  scale = 3.3121686421112381E-170;\n\n  /* Start for MATLABSystem: '<Root>/Pure Pursuit' */\n  absxk = fabs(x[0]);\n  if (absxk > 3.3121686421112381E-170) {\n    y = 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / 3.3121686421112381E-170;\n    y = t * t;\n  }\n\n  /* Start for MATLABSystem: '<Root>/Pure Pursuit' */\n  absxk = fabs(x[1]);\n  if (absxk > scale) {\n    t = scale / absxk;\n    y = y * t * t + 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / scale;\n    y += t * t;\n  }\n\n  return scale * sqrt(y);\n}\n\nstatic real_T closestPointOnLine(const real_T pt1[2], real_T pt2[2], const\n  real_T refPt[2])\n{\n  real_T refPt_0[2];\n  real_T alpha;\n  real_T distance;\n  real_T v12;\n  real_T v12_0;\n  int32_T b_k;\n  boolean_T exitg1;\n  boolean_T p;\n  boolean_T p_0;\n\n  /* Start for MATLABSystem: '<Root>/Pure Pursuit' */\n  p = false;\n  p_0 = true;\n  b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (b_k < 2)) {\n    if (!(pt1[b_k] == pt2[b_k])) {\n      p_0 = false;\n      exitg1 = true;\n    } else {\n      b_k++;\n    }\n  }\n\n  if (p_0) {\n    p = true;\n  }\n\n  if (p) {\n    pt2[0] = pt1[0];\n    refPt_0[0] = refPt[0] - pt1[0];\n    pt2[1] = pt1[1];\n    refPt_0[1] = refPt[1] - pt1[1];\n    distance = norm(refPt_0);\n  } else {\n    alpha = pt2[0] - pt1[0];\n    v12 = (pt2[0] - refPt[0]) * alpha;\n    v12_0 = alpha * alpha;\n    alpha = pt2[1] - pt1[1];\n    alpha = ((pt2[1] - refPt[1]) * alpha + v12) / (alpha * alpha + v12_0);\n    if (alpha > 1.0) {\n      pt2[0] = pt1[0];\n      pt2[1] = pt1[1];\n    } else if (!(alpha < 0.0)) {\n      pt2[0] = (1.0 - alpha) * pt2[0] + alpha * pt1[0];\n      pt2[1] = (1.0 - alpha) * pt2[1] + alpha * pt1[1];\n    }\n\n    refPt_0[0] = refPt[0] - pt2[0];\n    refPt_0[1] = refPt[1] - pt2[1];\n    distance = norm(refPt_0);\n  }\n\n  /* End of Start for MATLABSystem: '<Root>/Pure Pursuit' */\n  return distance;\n}\n\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\n    y = (rtNaN);\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\n    int32_T tmp;\n    int32_T tmp_0;\n    if (u0 > 0.0) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u1 > 0.0) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = atan2(tmp, tmp_0);\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = atan2(u0, u1);\n  }\n\n  return y;\n}\n\n/* Model step function */\nvoid robocar_c_step(void)\n{\n  real_T lookaheadStartPt[2];\n  real_T rtb_path_0[2];\n  real_T rtb_path_1[2];\n  real_T dist;\n  real_T lookaheadEndPt_idx_0;\n  real_T lookaheadEndPt_idx_1;\n  real_T lookaheadIdx;\n  real_T minDistance;\n  int32_T b_k;\n  int32_T rtb_path_tmp_tmp;\n  int32_T rtb_path_tmp_tmp_0;\n  int32_T trueCount;\n  int8_T rtb_path[8];\n  int8_T tmp_data[4];\n  int8_T rtb_path_tmp;\n  int8_T rtb_path_tmp_0;\n  boolean_T p;\n  boolean_T searchFlag;\n  static const int8_T tmp[8] = { 4, 6, 8, 10, 5, -5, 5, -5 };\n\n  int32_T tmp_size_idx_0;\n  boolean_T exitg1;\n\n  /* MATLAB Function: '<Root>/MATLAB Function2' */\n  for (b_k = 0; b_k < 8; b_k++) {\n    rtb_path[b_k] = tmp[b_k];\n  }\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function2' */\n\n  /* MATLABSystem: '<Root>/Pure Pursuit' incorporates:\n   *  Inport: '<Root>/Input1'\n   *  Inport: '<Root>/Input2'\n   */\n  if (rtDW.obj.MaxAngularVelocity != 1.0) {\n    rtDW.obj.MaxAngularVelocity = 1.0;\n  }\n\n  if ((rtDW.obj.DesiredLinearVelocity == rtU.Input1) || (rtIsNaN\n       (rtDW.obj.DesiredLinearVelocity) && rtIsNaN(rtU.Input1))) {\n  } else {\n    rtDW.obj.DesiredLinearVelocity = rtU.Input1;\n  }\n\n  if ((rtDW.obj.LookaheadDistance == rtU.Input2) || (rtIsNaN\n       (rtDW.obj.LookaheadDistance) && rtIsNaN(rtU.Input2))) {\n  } else {\n    rtDW.obj.LookaheadDistance = rtU.Input2;\n  }\n\n  searchFlag = false;\n  p = true;\n  b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (b_k < 8)) {\n    if (rtDW.obj.WaypointsInternal[b_k] == rtb_path[b_k]) {\n      b_k++;\n    } else {\n      p = false;\n      exitg1 = true;\n    }\n  }\n\n  if (p) {\n    searchFlag = true;\n  }\n\n  if (!searchFlag) {\n    for (b_k = 0; b_k < 8; b_k++) {\n      rtDW.obj.WaypointsInternal[b_k] = rtb_path[b_k];\n    }\n\n    rtDW.obj.ProjectionLineIndex = 0.0;\n  }\n\n  trueCount = 0;\n  for (b_k = 0; b_k < 4; b_k++) {\n    trueCount++;\n  }\n\n  tmp_size_idx_0 = trueCount;\n  trueCount = 0;\n  for (b_k = 0; b_k < 4; b_k++) {\n    /* MATLABSystem: '<Root>/Pure Pursuit' */\n    tmp_data[trueCount] = (int8_T)b_k;\n    trueCount++;\n  }\n\n  /* MATLABSystem: '<Root>/Pure Pursuit' incorporates:\n   *  Inport: '<Root>/Input'\n   * */\n  if (tmp_size_idx_0 == 0) {\n    /* Outport: '<Root>/Out1' */\n    rtY.Out1 = 0.0;\n    minDistance = 0.0;\n  } else {\n    searchFlag = false;\n    if (rtDW.obj.ProjectionLineIndex == 0.0) {\n      searchFlag = true;\n      rtDW.obj.ProjectionPoint[0] = rtb_path[tmp_data[0]];\n      rtDW.obj.ProjectionPoint[1] = rtb_path[tmp_data[0] + 4];\n      rtDW.obj.ProjectionLineIndex = 1.0;\n    }\n\n    if (tmp_size_idx_0 == 1) {\n      lookaheadEndPt_idx_0 = rtb_path[tmp_data[0]];\n      rtDW.obj.ProjectionPoint[0] = lookaheadEndPt_idx_0;\n      lookaheadEndPt_idx_1 = rtb_path[tmp_data[0] + 4];\n      rtDW.obj.ProjectionPoint[1] = lookaheadEndPt_idx_1;\n    } else {\n      b_k = tmp_data[(int32_T)(rtDW.obj.ProjectionLineIndex + 1.0) - 1];\n      lookaheadStartPt[0] = rtb_path[b_k];\n      lookaheadStartPt[1] = rtb_path[b_k + 4];\n      minDistance = closestPointOnLine(rtDW.obj.ProjectionPoint,\n        lookaheadStartPt, &rtU.Input[0]);\n      rtDW.obj.ProjectionPoint[0] = lookaheadStartPt[0];\n      rtb_path_0[0] = lookaheadStartPt[0] - (real_T)rtb_path[tmp_data[(int32_T)\n        (rtDW.obj.ProjectionLineIndex + 1.0) - 1]];\n      rtDW.obj.ProjectionPoint[1] = lookaheadStartPt[1];\n      rtb_path_0[1] = lookaheadStartPt[1] - (real_T)rtb_path[tmp_data[(int32_T)\n        (rtDW.obj.ProjectionLineIndex + 1.0) - 1] + 4];\n      dist = norm(rtb_path_0);\n      lookaheadIdx = rtDW.obj.ProjectionLineIndex + 1.0;\n      b_k = (int32_T)((1.0 - (rtDW.obj.ProjectionLineIndex + 1.0)) + ((real_T)\n        tmp_size_idx_0 - 1.0)) - 1;\n      trueCount = 0;\n      exitg1 = false;\n      while ((!exitg1) && (trueCount <= b_k)) {\n        lookaheadEndPt_idx_0 = lookaheadIdx + (real_T)trueCount;\n        if ((!searchFlag) && (dist > rtDW.obj.LookaheadDistance)) {\n          exitg1 = true;\n        } else {\n          rtb_path_tmp_tmp_0 = tmp_data[(int32_T)(lookaheadEndPt_idx_0 + 1.0) -\n            1];\n          rtb_path_tmp = rtb_path[rtb_path_tmp_tmp_0];\n          rtb_path_tmp_tmp = tmp_data[(int32_T)lookaheadEndPt_idx_0 - 1];\n          rtb_path_tmp_0 = rtb_path[rtb_path_tmp_tmp];\n          rtb_path_0[0] = rtb_path_tmp_0 - rtb_path_tmp;\n          lookaheadStartPt[0] = rtb_path_tmp;\n          rtb_path_1[0] = rtb_path_tmp_0;\n          rtb_path_tmp = rtb_path[rtb_path_tmp_tmp_0 + 4];\n          rtb_path_tmp_0 = rtb_path[rtb_path_tmp_tmp + 4];\n          rtb_path_0[1] = rtb_path_tmp_0 - rtb_path_tmp;\n          lookaheadStartPt[1] = rtb_path_tmp;\n          rtb_path_1[1] = rtb_path_tmp_0;\n          dist += norm(rtb_path_0);\n          lookaheadEndPt_idx_1 = closestPointOnLine(rtb_path_1, lookaheadStartPt,\n            &rtU.Input[0]);\n          if (lookaheadEndPt_idx_1 < minDistance) {\n            minDistance = lookaheadEndPt_idx_1;\n            rtDW.obj.ProjectionPoint[0] = lookaheadStartPt[0];\n            rtDW.obj.ProjectionPoint[1] = lookaheadStartPt[1];\n            rtDW.obj.ProjectionLineIndex = lookaheadEndPt_idx_0;\n          }\n\n          trueCount++;\n        }\n      }\n\n      b_k = tmp_data[(int32_T)(rtDW.obj.ProjectionLineIndex + 1.0) - 1];\n      lookaheadEndPt_idx_0 = rtb_path[b_k];\n      rtb_path_0[0] = rtDW.obj.ProjectionPoint[0] - lookaheadEndPt_idx_0;\n      lookaheadEndPt_idx_1 = rtb_path[b_k + 4];\n      rtb_path_0[1] = rtDW.obj.ProjectionPoint[1] - lookaheadEndPt_idx_1;\n      dist = norm(rtb_path_0);\n      lookaheadStartPt[0] = rtDW.obj.ProjectionPoint[0];\n      lookaheadStartPt[1] = rtDW.obj.ProjectionPoint[1];\n      minDistance = dist - rtDW.obj.LookaheadDistance;\n      lookaheadIdx = rtDW.obj.ProjectionLineIndex;\n      while ((minDistance < 0.0) && (lookaheadIdx < (real_T)tmp_size_idx_0 - 1.0))\n      {\n        lookaheadIdx++;\n        b_k = tmp_data[(int32_T)lookaheadIdx - 1];\n        rtb_path_tmp = rtb_path[b_k];\n        lookaheadStartPt[0] = rtb_path_tmp;\n        trueCount = tmp_data[(int32_T)(lookaheadIdx + 1.0) - 1];\n        rtb_path_tmp_0 = rtb_path[trueCount];\n        lookaheadEndPt_idx_0 = rtb_path_tmp_0;\n        rtb_path_0[0] = rtb_path_tmp - rtb_path_tmp_0;\n        rtb_path_tmp = rtb_path[b_k + 4];\n        lookaheadStartPt[1] = rtb_path_tmp;\n        rtb_path_tmp_0 = rtb_path[trueCount + 4];\n        lookaheadEndPt_idx_1 = rtb_path_tmp_0;\n        rtb_path_0[1] = rtb_path_tmp - rtb_path_tmp_0;\n        dist += norm(rtb_path_0);\n        minDistance = dist - rtDW.obj.LookaheadDistance;\n      }\n\n      rtb_path_0[0] = lookaheadStartPt[0] - lookaheadEndPt_idx_0;\n      rtb_path_0[1] = lookaheadStartPt[1] - lookaheadEndPt_idx_1;\n      dist = minDistance / norm(rtb_path_0);\n      if (dist > 0.0) {\n        lookaheadEndPt_idx_0 = (1.0 - dist) * lookaheadEndPt_idx_0 + dist *\n          lookaheadStartPt[0];\n        lookaheadEndPt_idx_1 = (1.0 - dist) * lookaheadEndPt_idx_1 + dist *\n          lookaheadStartPt[1];\n      }\n    }\n\n    rtDW.obj.LookaheadPoint[0] = lookaheadEndPt_idx_0;\n    rtDW.obj.LookaheadPoint[1] = lookaheadEndPt_idx_1;\n    dist = rt_atan2d_snf(rtDW.obj.LookaheadPoint[1] - rtU.Input[1],\n                         rtDW.obj.LookaheadPoint[0] - rtU.Input[0]) - rtU.Input\n      [2];\n    if (fabs(dist) > 3.1415926535897931) {\n      if (rtIsNaN(dist + 3.1415926535897931) || rtIsInf(dist +\n           3.1415926535897931)) {\n        minDistance = (rtNaN);\n      } else if (dist + 3.1415926535897931 == 0.0) {\n        minDistance = 0.0;\n      } else {\n        minDistance = fmod(dist + 3.1415926535897931, 6.2831853071795862);\n        searchFlag = (minDistance == 0.0);\n        if (!searchFlag) {\n          lookaheadIdx = fabs((dist + 3.1415926535897931) / 6.2831853071795862);\n          searchFlag = !(fabs(lookaheadIdx - floor(lookaheadIdx + 0.5)) >\n                         2.2204460492503131E-16 * lookaheadIdx);\n        }\n\n        if (searchFlag) {\n          minDistance = 0.0;\n        } else if (minDistance < 0.0) {\n          minDistance += 6.2831853071795862;\n        }\n      }\n\n      if ((minDistance == 0.0) && (dist + 3.1415926535897931 > 0.0)) {\n        minDistance = 6.2831853071795862;\n      }\n\n      dist = minDistance - 3.1415926535897931;\n    }\n\n    minDistance = 2.0 * sin(dist) / rtDW.obj.LookaheadDistance;\n    if (rtIsNaN(minDistance)) {\n      minDistance = 0.0;\n    }\n\n    if (fabs(fabs(dist) - 3.1415926535897931) < 1.4901161193847656E-8) {\n      if (rtIsNaN(minDistance)) {\n        minDistance = (rtNaN);\n      } else if (minDistance < 0.0) {\n        minDistance = -1.0;\n      } else {\n        minDistance = (minDistance > 0.0);\n      }\n    }\n\n    if (fabs(minDistance) > 1.0) {\n      if (rtIsNaN(minDistance)) {\n        minDistance = (rtNaN);\n      } else if (minDistance < 0.0) {\n        minDistance = -1.0;\n      } else {\n        minDistance = (minDistance > 0.0);\n      }\n    }\n\n    /* Outport: '<Root>/Out1' incorporates:\n     *  Inport: '<Root>/Input'\n     * */\n    rtY.Out1 = rtDW.obj.DesiredLinearVelocity;\n    rtDW.obj.LastPose[0] = rtU.Input[0];\n    rtDW.obj.LastPose[1] = rtU.Input[1];\n    rtDW.obj.LastPose[2] = rtU.Input[2];\n  }\n\n  /* Outport: '<Root>/Out2' incorporates:\n   *  MATLABSystem: '<Root>/Pure Pursuit'\n   */\n  rtY.Out2 = minDistance;\n}\n\n/* Model initialize function */\nvoid robocar_c_initialize(void)\n{\n  {\n    int32_T i;\n\n    /* Start for MATLABSystem: '<Root>/Pure Pursuit' */\n    rtDW.obj.MaxAngularVelocity = 1.0;\n    rtDW.obj.isInitialized = 1;\n    rtDW.obj.DesiredLinearVelocity = 0.0;\n    rtDW.obj.LookaheadDistance = 0.0;\n    for (i = 0; i < 8; i++) {\n      rtDW.obj.WaypointsInternal[i] = (rtNaN);\n    }\n\n    /* InitializeConditions for MATLABSystem: '<Root>/Pure Pursuit' */\n    rtDW.obj.LookaheadPoint[0] = 0.0;\n    rtDW.obj.LookaheadPoint[1] = 0.0;\n    rtDW.obj.LastPose[0] = 0.0;\n    rtDW.obj.LastPose[1] = 0.0;\n    rtDW.obj.LastPose[2] = 0.0;\n    rtDW.obj.ProjectionPoint[0] = (rtNaN);\n    rtDW.obj.ProjectionPoint[1] = (rtNaN);\n    rtDW.obj.ProjectionLineIndex = 0.0;\n  }\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"robocar_c.h","type":"header","group":"model","path":"/Users/saucesaft/Documents/MATLAB/5to_Semestre/setpoint/robocar_c_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: robocar_c.h\n *\n * Code generated for Simulink model 'robocar_c'.\n *\n * Model version                  : 2.43\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Fri Nov 29 12:10:28 2024\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#ifndef robocar_c_h_\n#define robocar_c_h_\n#ifndef robocar_c_COMMON_INCLUDES_\n#define robocar_c_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"math.h\"\n#endif                                 /* robocar_c_COMMON_INCLUDES_ */\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM RT_MODEL;\n\n#ifndef struct_tag_BlgwLpgj2bjudmbmVKWwDE\n#define struct_tag_BlgwLpgj2bjudmbmVKWwDE\n\nstruct tag_BlgwLpgj2bjudmbmVKWwDE\n{\n  uint32_T f1[8];\n};\n\n#endif                                 /* struct_tag_BlgwLpgj2bjudmbmVKWwDE */\n\n#ifndef typedef_cell_wrap\n#define typedef_cell_wrap\n\ntypedef struct tag_BlgwLpgj2bjudmbmVKWwDE cell_wrap;\n\n#endif                                 /* typedef_cell_wrap */\n\n#ifndef struct_tag_DwkamkaJN4l1qSsZxTESCB\n#define struct_tag_DwkamkaJN4l1qSsZxTESCB\n\nstruct tag_DwkamkaJN4l1qSsZxTESCB\n{\n  int32_T isInitialized;\n  cell_wrap inputVarSize[4];\n  real_T MaxAngularVelocity;\n  real_T LookaheadDistance;\n  real_T DesiredLinearVelocity;\n  real_T ProjectionPoint[2];\n  real_T ProjectionLineIndex;\n  real_T LookaheadPoint[2];\n  real_T LastPose[3];\n  real_T WaypointsInternal[8];\n};\n\n#endif                                 /* struct_tag_DwkamkaJN4l1qSsZxTESCB */\n\n#ifndef typedef_nav_slalgs_internal_PurePursuit\n#define typedef_nav_slalgs_internal_PurePursuit\n\ntypedef struct tag_DwkamkaJN4l1qSsZxTESCB nav_slalgs_internal_PurePursuit;\n\n#endif                             /* typedef_nav_slalgs_internal_PurePursuit */\n\n/* Block signals and states (default storage) for system '<Root>' */\ntypedef struct {\n  nav_slalgs_internal_PurePursuit obj; /* '<Root>/Pure Pursuit' */\n} DW;\n\n/* External inputs (root inport signals with default storage) */\ntypedef struct {\n  real_T Input[3];                     /* '<Root>/Input' */\n  real_T Input1;                       /* '<Root>/Input1' */\n  real_T Input2;                       /* '<Root>/Input2' */\n} ExtU;\n\n/* External outputs (root outports fed by signals with default storage) */\ntypedef struct {\n  real_T Out1;                         /* '<Root>/Out1' */\n  real_T Out2;                         /* '<Root>/Out2' */\n} ExtY;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM {\n  const char_T * volatile errorStatus;\n};\n\n/* Block signals and states (default storage) */\nextern DW rtDW;\n\n/* External inputs (root inport signals with default storage) */\nextern ExtU rtU;\n\n/* External outputs (root outports fed by signals with default storage) */\nextern ExtY rtY;\n\n/* Model entry point functions */\nextern void robocar_c_initialize(void);\nextern void robocar_c_step(void);\n\n/* Real-time Model object */\nextern RT_MODEL *const rtM;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'robocar_c'\n * '<S1>'   : 'robocar_c/MATLAB Function2'\n */\n#endif                                 /* robocar_c_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/saucesaft/Documents/MATLAB/5to_Semestre/setpoint/robocar_c_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'robocar_c'.\n *\n * Model version                  : 2.43\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Fri Nov 29 12:10:28 2024\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: ARM Compatible->ARM Cortex-M\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  32    long long:  64\n *                       native word size:  32\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long long int64_T;\ntypedef unsigned long long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};